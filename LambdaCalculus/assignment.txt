Seán Edward Comerford
15485892
Lambda Calculus Assignment

Part 1

kons = λ a d z . z false a d
kar = λ p . p (λ n a d . a)
kdr = λ p . p (λ n a d . d)
null = λ z . z true false false
null? = λ p . p (λ n a d . n)
true = λ a b . a
false = λ a b . b

kar (kons e1 e2) ↝ e1
Lets focus on the kons e1 e2 and then substitute that into kar
kons = (lambda a d z . z false a d)
(lambda a d z . z false a d) e1 e2

Beta Reduction:
(z false a d)[a:=e1]
(z false e1 d)[d:=e2]
(z false e1 e2)

(lambda z . z false e1 e2)
We can now use this with kar
kar= (lambda p . p(lambda n a d . a))
(lambda p . p(lambda n a d . a))(lambda z . z false e1 e2)

Beta Reduction:
(p(lambda n a d . a))[p:=(lambda z . z false e1 e2)]
(lambda z . z false e1 e2)(lambda n a d . a)

Beta Reduction:
(z false e1 e2)[z:=(lambda n a d . a)]
((lambda n a d . a) false e1 e2)

/*(lambda n a d . a ) takes in three inputs, n a d and returns a */
(lambda n a d . a)[n:=false, a:=e1, d:=e2]
e1

kdr (kons e1 e2) ↝ e2
Lets focus on the kons e1 e2 and then substitute that into kar
kons = (lambda a d z . z false a d)
(lambda a d z . z false a d) e1 e2

Beta Reduction:
(z false a d)[a:=e1]
(z false e1 d)[d:=e2]
(z false e1 e2)

(lambda z . z false e1 e2)
We can now use this with kdr
kdr=(lambda p . p (lambda n a d . d))

(lambda p . p(lambda n a d . d))(lambda z . z false e1 e2)

Beta Reduction:
(p(lambda n a d . d))[p:=(lambda z . z false e1 e2)]
((lambda z . z false e1 e2)(lambda n a d . d))

Beta Reduction:
(z false e1 e2)[z:(lambda n a d . d)]
((lambda n a d . d) false e1 e2)
[n:=false, a:=e1, d:=e2]
e2

null? (kons e1 e2) ↝  false
Deal with (kons e1 e2 first)
kons = (lambda a d z . z false a d)
(lambda a d z . z false a d) e1 e2

Beta Reduction:
(z false a d)[a:=e1]
(z false e1 d)
(z false e1 d)[d:=e2]
(z false e1 e2)

(lambda z . z false e1 e2)

Now we can substitute this back into null? and see if it returns false
null? = (lambda p . p (lambda n a d . n))
(lambda p . p (lambda n a d . n))(lambda z . z false e1 e2)

Beta Reduction:
(p (lambda n a d . n))[p:=(lambda z .z false e1 e2)]
((lambda z .z false e1 e2)(lambda n a d . n))

Beta Reducution:
(z false e1 e2) [z:=(lambda n a d . n)]
((lambda n a d . n) false e1 e2)

Beta Reduction:
(n) [n:=false , a:=e1 , d:=e2]
(false)
false

null? null ↝ true
(lambda p. p(lambda n a d . n))(lambda z. z true false false)

Beta Reduction:
p(lambda n a d . n)[p:= (lambda z . z true false false)]
(lambda z . z true false false)(lambda n a d . n)

Beta Reduction:
(z true false false)[z:=(lambda n a d . n)]
((lambda n a d . n) true false false)

Beta Reduction:
(n) [n:= true]
(true)
true
// this is because lambda n a d takes in 3 variables(true, false, false respectively) and returns the first, which is true

Part 2:

(lambda c . (lambda a . (lambda d . (lambda h . (h (d (a (a (lambda z y . y))) (d (a (a (lambda f x . x))) (a (a (a (lambda z x . x)))))) (h (a (a (lambda z y . y))) (a (a (a (lambda z x . x))))))) (lambda n m . n (d m) (lambda z y . y))) (lambda n m . n a m)) (lambda n z . c (n z) z)) (lambda z g x . z (g x))

Easier to read:

	(lambda c . 
	(lambda a . 
	(lambda d . 
	(lambda h . 
	(h (d (a (a (lambda z y . y))) 
	(d (a (a (lambda f x . x))) 
	(a (a (a (lambda z x . x)))))) 
	(h (a (a (lambda z y . y))) 
	(a (a (a (lambda z x . x))))))) 
	(lambda n m . n (d m) (lambda z y . y))) 
	(lambda n m . n a m)) 
	(lambda n z . c (n z) z)) 
	(lambda z g x . z (g x))

Solutions
	(lambda n m . n (d m) (lambda z y . y)))  = (lambda n. n (lambda z y . y)) = (lambda z y . y)
	(lambda n m . n a m)) = (lambda n . n a) = a
	(lambda n z . c (n z) z))  = c
	(lambda z g x . z (g x)) = (lambda z g. z)

Using above reduces to
	(lambda c . 
	(lambda a . 
	(lambda d . 
	(lambda h . 
	(h (d (a (a (lambda z y . y))) 
	(d (a (a (lambda f x . x))) 
	(a (a (a (lambda z x . x)))))) 
	(h (a (a (lambda z y . y))) 
	(a (a (a (lambda z x . x))))))) 
	(lambda z y . y)) 
	 a)
	 c)
	(lambda z g. z)

C is an unbound variable so it can be reduced to:
	(lambda a . 
	(lambda d . 
	(lambda h . 
	(h (d (a (a (lambda z y . y))) 
	(d (a (a (lambda f x . x))) 
	(a (a (a (lambda z x . x)))))) 
	(h (a (a (lambda z y . y))) 
	(a (a (a (lambda z x . x))))))) 
	(lambda z y . y)) 
	 a)
	(lambda z g. z)


Reduce d to (lambda z y . y)
	(lambda h . 
	(h (lambda z y . y (a (a (lambda z y . y))) 
	(lambda z y . y(a (a (lambda f x . x))) 
	(a (a (a (lambda z x . x)))))) 
	(h (a (a (lambda z y . y))) 
	(a (a (a (lambda z x . x)))))))  
	(lambda z g. z)


Alpha renaming 
	(lambda h . 
	(h (lambda z y . y (a (a (lambda z y . y))) 
	((lambda z y . y (a (a (lambda f x . x))) 
	((lambda z x . x))(a (a(lambda f x . x)))) 
	(a (a (a (lambda z y . y))) 
	(h (a (a (lambda z x . x))))))
	(a(a(a(lambda zj. j)))))))
	(lambda kg.k)

Beta Reduce h to lambda k g.k
	(lambda k g.k (lambda z y . y (a (a (lambda z y . y))) 
	((lambda z y . y (a (a (lambda f x . x))) 
	(a (a (a (lambda z y . y))) 
	(lambda kg.k (a (a (lambda z x . x))))))
	(a(a(a(lambda zj. j)))))))

Alpha Renaming
	(lambda k g.k (lambda z y . y (a (a (lambda z y . y))) 
	((lambda z y . y (a (a (lambda f x . x))) 
	(a (a (a (lambda z y . y))) 
	(lambda z x . z(a(a(lambdazj.j)))))
	(a(a(a(lambda rs. s))))))))

Beta Reducution
	(lambda g(lambda z y . y (a (a (lambda z y . y))) 
	((lambda z y . y (a (a (lambda f x . x))) 
	(a (a (a (lambda z y . y))) 
	(lambda z x . z(a(a(lambdazj.j)))))
	(a(a(a(lambda rs. s))))))))

Beta Reduce g to (lambda z x . z(a(a(lambdazj.j)))(a(a(a(lambda rs. s)))))
	(lambda z y . y (a (a (lambda z y . y))) 
	((lambda z y . y (a (a (lambda f x . x))) 
	(a (a (a (lambda z y . y)))))))

Beta Reduction
	(lambda z y . y
	((lambda z y . y (a (a (lambda f x . x))) 
	(a (a (a (lambda z y . y)))))))

Beta Reduction
	(lambda z y . y (a (a (lambda f x . x)))(a (a (a (lambda z y . y)))))))

Beta Reduction
	(lambda y . y(a (a (a (lambda z y . y)))))

Beta Reduction to Normal form
	(a (a (a (lambda z y . y))))
